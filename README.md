# Реализация Singleton на базе ортогональных стратегий (по мотивам Modern C++ Александреску)

## Цель работы

- Реализовать шаблон проектирования Singleton с поддержкой ортогональных стратегий, в частности:
  - Стратегии синхронизации для многопоточной среды
  - Возможности расширения другими стратегиями по аналогии с библиотекой Loki

## Реализованная функциональность

1. **Базовый класс стратегии синхронизации** (`SyncStrategy`):
   - Абстрактный интерфейс с методами `lock()` и `unlock()`
   - Виртуальный деструктор для корректного удаления производных классов

2. **Конкретная стратегия на основе std::mutex** (`MutexSync`):
   - Реализация интерфейса `SyncStrategy`
   - Использование стандартного мьютекса для синхронизации

3. **Шаблонный класс Singleton**:
   - Поддержка произвольных типов (Generics)
   - Возможность выбора стратегии синхронизации (по умолчанию `MutexSync`)
   - Защита от копирования и присваивания
   - Ленивая инициализация (по требованию)
   - Потокобезопасное создание экземпляра

4. **Пример использования**:
   - Демонстрационный класс `MyClass`
   - Получение экземпляра через `Singleton<MyClass>::getInstance()`

## Особенности реализации

- Использование `unique_ptr` для управления временем жизни Singleton
- Шаблонный дизайн позволяет легко добавлять новые стратегии
- Соответствует принципам SOLID (особенно принципу открытости/закрытости)

## Возможные улучшения

- **Добавление других стратегий синхронизации**:
  - Атомарные операции
  - Двойная проверка блокировки
  - Без блокировок (для однопоточных приложений)

- **Расширение системы стратегий**:
  - Управление временем жизни
  - Политики создания объектов

- **Дополнительные гарантии безопасности**:
  - Обработка исключений при создании
  - Защита от `static initialization order fiasco`

## Как использовать

```cpp
// 1. Определите свой класс
class MyService {
public:
    void operation() { /* ... */ }
};

// 2. Получайте экземпляр через Singleton
auto& service = Singleton<MyService>::getInstance();
service.operation();
```

Для использования другой стратегии синхронизации:

```cpp
class CustomSync : public SyncStrategy { /* ... */ };
auto& service = Singleton<MyService, CustomSync>::getInstance();
```
